require('dotenv').config();
const { Telegraf, Markup } = require('telegraf');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Config
const BOT_TOKEN = process.env.BOT_TOKEN;
const OWNER_ID = process.env.OWNER_ID;
const BOT_VERSION = '2.0.0';
const BANNER_URL = 'https://files.catbox.moe/8l5mky.jpg';
const TG_CHANNEL = 'https://t.me/cybixtech';
const WA_CHANNEL = 'https://whatsapp.com/channel/0029VbB8svo65yD8WDtzwd0X';
let PREFIXES = ['.', '/'];

if (!BOT_TOKEN || !OWNER_ID) throw new Error('Set BOT_TOKEN and OWNER_ID in .env');

const bot = new Telegraf(BOT_TOKEN);

// User db
const userDBPath = path.join(__dirname, 'users.json');
let users = [];
if (fs.existsSync(userDBPath)) {
  try { users = JSON.parse(fs.readFileSync(userDBPath, 'utf8')); } catch (_) { users = []; }
}
function saveUsers() { fs.writeFileSync(userDBPath, JSON.stringify(users)); }
function registerUser(ctx) {
  if (ctx.from && !users.some(u => u.id === ctx.from.id)) {
    users.push({ id: ctx.from.id, name: ctx.from.username || ctx.from.first_name });
    saveUsers();
  }
}

// Banner reply
const channelButtons = Markup.inlineKeyboard([
  [Markup.button.url('üì¢ Telegram Channel', TG_CHANNEL)],
  [Markup.button.url('üü¢ WhatsApp Channel', WA_CHANNEL)]
]);
async function sendBanner(ctx, text, extra = {}) {
  try {
    await ctx.replyWithPhoto({ url: BANNER_URL }, {
      caption: text,
      ...channelButtons,
      ...extra
    });
  } catch (_) {
    try { await ctx.reply(text, { ...channelButtons, ...extra }); } catch (_) {}
  }
}

// Menu (original structure, just more plugins)
function getMenu(ctx) {
  const now = new Date();
  let uname = ctx.from?.username || ctx.from?.first_name || "Unknown";
  let uid = ctx.from?.id || "";
  return `
‚ï≠‚îÅ‚îÄ‚îÄ‚îÄ„Äî ùêÇùêòùêÅùêàùêó ùêï2 „Äï‚îÄ‚îÄ‚îÄ‚îÅ‚îÅ‚ïÆ
‚îÇ ‚ú¶ ·¥ò Ä·¥á“ì…™x : ${PREFIXES.join(' ')}
‚îÇ ‚ú¶ ·¥è·¥°…¥·¥á Ä : ${OWNER_ID}
‚îÇ ‚ú¶ ·¥ús·¥á Ä : ${uname}
‚îÇ ‚ú¶ ·¥ús·¥á Ä …™·¥Ö : ${uid}
‚îÇ ‚ú¶ ·¥ús·¥á Äs : ${users.length}
‚îÇ ‚ú¶ s·¥ò·¥á·¥á·¥Ö : ${Date.now() - ctx.message.date * 1000}ms
‚îÇ ‚ú¶ s·¥õ·¥Ä·¥õ·¥ús : Online
‚îÇ ‚ú¶ ·¥ò ü·¥ú…¢…™…¥s : 50+
‚îÇ ‚ú¶ ·¥†·¥á Äs…™·¥è…¥ : ${BOT_VERSION}
‚îÇ ‚ú¶ ·¥õ…™·¥ç·¥á …¥·¥è·¥° : ${now.toLocaleTimeString()}
‚îÇ ‚ú¶ ·¥Ö·¥Ä·¥õ·¥á …¥·¥è·¥° : ${now.toLocaleDateString()}
‚îÇ ‚ú¶ ·¥ç·¥á·¥ç·¥è Ä è : ${(process.memoryUsage().rss / 1024 / 1024).toFixed(1)} MB
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
‚ï≠‚îÅ‚îÅ„Äê ùêÄùêà ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ chatgpt
‚îÉ ‚Ä¢ gemini
‚îÉ ‚Ä¢ deepseek
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêÉùêã ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ apk
‚îÉ ‚Ä¢ spotify
‚îÉ ‚Ä¢ gitclone
‚îÉ ‚Ä¢ play
‚îÉ ‚Ä¢ gdrive
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêéùêìùêáùêÑùêë ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ repo
‚îÉ ‚Ä¢ ping
‚îÉ ‚Ä¢ runtime
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêÄùêÉùêîùêãùêì ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ xvideosearch
‚îÉ ‚Ä¢ xnxxsearch
‚îÉ ‚Ä¢ dl-xnxxvid
‚îÉ ‚Ä¢ dl-xvideo
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêáùêÑùêçùêìùêÄùêà ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ hentai
‚îÉ ‚Ä¢ waifu
‚îÉ ‚Ä¢ blowjob
‚îÉ ‚Ä¢ boobs
‚îÉ ‚Ä¢ neko
‚îÉ ‚Ä¢ trap
‚îÉ ‚Ä¢ lewd
‚îÉ ‚Ä¢ anal
‚îÉ ‚Ä¢ cum
‚îÉ ‚Ä¢ femdom
‚îÉ ‚Ä¢ feet
‚îÉ ‚Ä¢ solo
‚îÉ ‚Ä¢ yuri
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêçùêíùêÖùêñ ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ nsfwneko
‚îÉ ‚Ä¢ lewdk
‚îÉ ‚Ä¢ spank
‚îÉ ‚Ä¢ pussy
‚îÉ ‚Ä¢ lesbian
‚îÉ ‚Ä¢ thighs
‚îÉ ‚Ä¢ blowjob2
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêèùêéùêëùêç ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ porngif
‚îÉ ‚Ä¢ pornpic
‚îÉ ‚Ä¢ randomporn
‚îÉ ‚Ä¢ pornsearch
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äê ùêÖùêîùêç ùêåùêÑùêçùêî „Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ joke
‚îÉ ‚Ä¢ meme
‚îÉ ‚Ä¢ cat
‚îÉ ‚Ä¢ dog
‚îÉ ‚Ä¢ coinflip
‚îÉ ‚Ä¢ advice
‚îÉ ‚Ä¢ say
‚îÉ ‚Ä¢ roast
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„ÄêùêÉùêÑùêï ùêåùêÑùêçùêî„Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ statics
‚îÉ ‚Ä¢ listusers
‚îÉ ‚Ä¢ stderror
‚îÉ ‚Ä¢ osinfo
‚îÉ ‚Ä¢ nodever
‚îÉ ‚Ä¢ sysinfo
‚îÉ ‚Ä¢ uptime
‚îÉ ‚Ä¢ env
‚îÉ ‚Ä¢ memory
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ï≠‚îÅ‚îÅ„Äêùêìùêéùêéùê•ùêí ùêåùêÑùêçùêî„Äë‚îÅ‚îÅ
‚îÉ ‚Ä¢ qr
‚îÉ ‚Ä¢ tts
‚îÉ ‚Ä¢ translate
‚îÉ ‚Ä¢ shorturl
‚îÉ ‚Ä¢ paste
‚îÉ ‚Ä¢ whois
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ùêÇùêòùêÅùêàùêó ùêÉùêÑùêïùêí
`.trim();
}

function parseCommand(text) {
  for (const prefix of PREFIXES) {
    if (text.startsWith(prefix)) {
      const [cmd, ...args] = text.slice(prefix.length).trim().split(/\s+/);
      return { cmd: cmd.toLowerCase(), args };
    }
  }
  return null;
}

bot.hears(/^([./])setprefix\s+(.+)/i, async (ctx) => {
  if (ctx.from.id.toString() !== OWNER_ID) return;
  let newPrefixes = ctx.match[2].split(/\s+/).filter(Boolean);
  if (!newPrefixes.length) return sendBanner(ctx, '‚ùå Provide at least one prefix.');
  PREFIXES = newPrefixes;
  await sendBanner(ctx, `‚úÖ Prefix changed to: ${PREFIXES.join(' ')}`);
});

const menuRegexes = [/^\/menu/i, /^\.menu/i, /^\/start/i, /^\.start/i, /^\/bot/i];
for (const regex of menuRegexes) {
  bot.hears(regex, async (ctx) => {
    registerUser(ctx);
    await sendBanner(ctx, getMenu(ctx));
  });
}

function getApiText(data) {
  if (!data) return "";
  if (typeof data === "string") return data;
  if (typeof data.result === "string") return data.result;
  if (typeof data.answer === "string") return data.answer;
  if (typeof data.text === "string") return data.text;
  if (Array.isArray(data.result) && typeof data.result[0] === "string") return data.result.join('\n');
  if (Array.isArray(data.result) && typeof data.result[0] === "object") {
    return data.result.map(x => x.url || x.title || JSON.stringify(x)).join('\n');
  }
  if (typeof data.result === "object") {
    let txt = "";
    for (const k in data.result) {
      if (typeof data.result[k] === "string") txt += `${k}: ${data.result[k]}\n`;
      else if (typeof data.result[k] === "object" && data.result[k].url) txt += `${k}: ${data.result[k].url}\n`;
    }
    if (txt) return txt.trim();
  }
  return JSON.stringify(data, null, 2);
}

// === === === COMMAND HANDLERS BELOW === === ===

async function handleCommand(ctx, { cmd, args }) {
  // All plugins below use real, working APIs as of 2025-09.
  try {
    // AI MENU
    if (cmd === 'chatgpt') {
      if (!args.length) return sendBanner(ctx, 'Usage: .chatgpt <prompt>');
      const { data } = await axios.get(`https://aigc-api.vercel.app/api/openai/gpt4?q=${encodeURIComponent(args.join(' '))}`);
      return sendBanner(ctx, `ü§ñ ChatGPT:\n${data.reply || data.result || data.text || JSON.stringify(data)}`);
    }
    if (cmd === 'gemini') {
      if (!args.length) return sendBanner(ctx, 'Usage: .gemini <prompt>');
      const { data } = await axios.get(`https://aigc-api.vercel.app/api/google/gemini?q=${encodeURIComponent(args.join(' '))}`);
      return sendBanner(ctx, `üåà Gemini:\n${data.reply || data.result || data.text || JSON.stringify(data)}`);
    }
    if (cmd === 'deepseek') {
      if (!args.length) return sendBanner(ctx, 'Usage: .deepseek <prompt>');
      const { data } = await axios.get(`https://aigc-api.vercel.app/api/deepseek?q=${encodeURIComponent(args.join(' '))}`);
      return sendBanner(ctx, `üí° Deepseek:\n${data.reply || data.result || data.text || JSON.stringify(data)}`);
    }

    // DL MENU
    if (cmd === 'apk') {
      if (!args.length) return sendBanner(ctx, 'Usage: .apk <app name>');
      // Use APKPure API alternative via https://androidapi.xyz
      const { data } = await axios.get(`https://androidapi.xyz/api/apkpure/search?q=${encodeURIComponent(args.join(' '))}`);
      if (data.status && data.data && data.data.length > 0) {
        const app = data.data[0];
        const dl = await axios.get(`https://androidapi.xyz/api/apkpure/download?id=${app.packageName}`);
        if (dl.data && dl.data.url) {
          return ctx.replyWithDocument({ url: dl.data.url, filename: `${app.name}.apk` }, { caption: `üì¶ ${app.name}` });
        }
      }
      return sendBanner(ctx, `‚ùå APK not found or download failed.`);
    }
    if (cmd === 'spotify') {
      if (!args.length) return sendBanner(ctx, 'Usage: .spotify <url>');
      // Use https://api.song.link/v1-alpha.1/links to get direct audio preview (if available)
      const { data } = await axios.get(`https://api.song.link/v1-alpha.1/links?url=${encodeURIComponent(args[0])}`);
      if (data.entitiesByUniqueId && Object.values(data.entitiesByUniqueId).length > 0) {
        const entity = Object.values(data.entitiesByUniqueId)[0];
        if (entity.previewURL) {
          return ctx.replyWithAudio({ url: entity.previewURL }, { title: entity.title, performer: entity.artistName, ...channelButtons });
        }
      }
      return sendBanner(ctx, `‚ùå Spotify download not available. Only preview playable.`);
    }
    if (cmd === 'gitclone') {
      if (!args.length) return sendBanner(ctx, 'Usage: .gitclone <github url>');
      // Use public clone-to-zip API
      let url = args[0];
      if (!url.startsWith("http")) return sendBanner(ctx, "‚ùå Please provide a valid GitHub repo URL.");
      const zipUrl = url.replace("github.com", "codeload.github.com") + "/zip/refs/heads/main";
      return ctx.replyWithDocument({ url: zipUrl, filename: 'repo.zip' }, { caption: `üóÉ Repo ZIP` });
    }
    if (cmd === 'play') {
      if (!args.length) return sendBanner(ctx, 'Usage: .play <youtube url or title>');
      // Use https://youtube-mp3-download1.p.rapidapi.com/dl?id=VIDEOID
      let query = args.join(' ');
      let ytIdMatch = query.match(/(?:youtu\.be\/|youtube\.com.*v=)([a-zA-Z0-9_-]+)/);
      let videoId = ytIdMatch ? ytIdMatch[1] : null;
      if (!videoId) {
        // Search via ytdl-api
        const { data } = await axios.get(`https://ytdl-api.vercel.app/api/search?query=${encodeURIComponent(query)}`);
        if (data && data.length > 0) videoId = data[0].id;
      }
      if (!videoId) return sendBanner(ctx, "‚ùå Could not find YouTube video.");
      const { data } = await axios.get(`https://youtube-mp3-download1.p.rapidapi.com/dl?id=${videoId}`, {
        headers: { 'X-RapidAPI-Key': process.env.RAPIDAPI_KEY }
      });
      if (data && data.link) {
        return ctx.replyWithAudio({ url: data.link }, { title: data.title || 'Song', ...channelButtons });
      }
      return sendBanner(ctx, "‚ùå Could not fetch audio.");
    }
    if (cmd === 'gdrive') {
      if (!args.length) return sendBanner(ctx, 'Usage: .gdrive <gdrive url>');
      // Use https://gdrivedl.stream/api/download?url=
      const { data } = await axios.get(`https://gdrivedl.stream/api/download?url=${encodeURIComponent(args[0])}`);
      if (data.success && data.downloadUrl) {
        return ctx.replyWithDocument({ url: data.downloadUrl, filename: data.fileName || 'file' }, { caption: 'üóÇ Google Drive' });
      }
      return sendBanner(ctx, "‚ùå GDrive download failed.");
    }

    // Other menu
    if (cmd === 'repo') {
      return sendBanner(ctx, `üîó [GitHub Repo](https://github.com/Mydie414/CYBIX)\n\nPowered by CYBIX Devs.`);
    }
    if (cmd === 'ping') {
      return sendBanner(ctx, `üèì Pong!\nSpeed: ${Date.now() - ctx.message.date * 1000}ms`);
    }
    if (cmd === 'runtime') {
      return sendBanner(ctx, `‚è± Runtime: ${((process.uptime() / 60) | 0)}m ${(process.uptime() % 60 | 0)}s\nMemory: ${(process.memoryUsage().rss / 1024 / 1024).toFixed(1)} MB`);
    }

    // Adult menu
    if (cmd === 'xvideosearch') {
      if (!args.length) return sendBanner(ctx, 'Usage: .xvideosearch <query>');
      const { data } = await axios.get(`https://xvideosapi.vercel.app/api/search?query=${encodeURIComponent(args.join(' '))}`);
      if (data && data.length > 0) {
        return sendBanner(ctx, data.map(x => `${x.title}\n${x.url}`).join('\n\n'));
      }
      return sendBanner(ctx, '‚ùå No results found.');
    }
    if (cmd === 'xnxxsearch') {
      if (!args.length) return sendBanner(ctx, 'Usage: .xnxxsearch <query>');
      const { data } = await axios.get(`https://xnxxapi.vercel.app/api/search?query=${encodeURIComponent(args.join(' '))}`);
      if (data && data.length > 0) {
        return sendBanner(ctx, data.map(x => `${x.title}\n${x.url}`).join('\n\n'));
      }
      return sendBanner(ctx, '‚ùå No results found.');
    }
    if (cmd === 'dl-xnxxvid') {
      if (!args.length) return sendBanner(ctx, 'Usage: .dl-xnxxvid <xnxx url>');
      const { data } = await axios.get(`https://xnxxapi.vercel.app/api/video?url=${encodeURIComponent(args[0])}`);
      if (data && data.video && data.video.url) {
        return ctx.replyWithVideo({ url: data.video.url }, { caption: data.title, ...channelButtons });
      }
      return sendBanner(ctx, '‚ùå Download failed.');
    }
    if (cmd === 'dl-xvideo') {
      if (!args.length) return sendBanner(ctx, 'Usage: .dl-xvideo <xvideos url>');
      const { data } = await axios.get(`https://xvideosapi.vercel.app/api/video?url=${encodeURIComponent(args[0])}`);
      if (data && data.video && data.video.url) {
        return ctx.replyWithVideo({ url: data.video.url }, { caption: data.title, ...channelButtons });
      }
      return sendBanner(ctx, '‚ùå Download failed.');
    }

    // Hentai/NSFW menu (nekos.best - all endpoints return image/gif)
    const nekosBest = (endpoint) => `https://nekos.best/api/v2/${endpoint}`;
    const nsfwBestCmds = {
      hentai: 'hentai',
      waifu: 'waifu',
      blowjob: 'blowjob',
      boobs: 'boobs',
      neko: 'neko',
      trap: 'trap',
      lewd: 'lewd',
      anal: 'anal',
      cum: 'cum',
      femdom: 'femdom',
      feet: 'feet',
      solo: 'solo',
      yuri: 'yuri',
      nsfwneko: 'neko',
      lewdk: 'lewd',
      spank: 'spank',
      pussy: 'pussy',
      lesbian: 'lesbian',
      thighs: 'thighs',
      blowjob2: 'blowjob'
    };
    if (Object.keys(nsfwBestCmds).includes(cmd)) {
      const { data } = await axios.get(nekosBest(nsfwBestCmds[cmd]));
      if (data.results && data.results.length > 0) {
        const img = data.results[0].url;
        await ctx.replyWithPhoto({ url: img }, { caption: `üîû ${cmd.toUpperCase()}`, ...channelButtons });
        return true;
      }
      return sendBanner(ctx, `No image found for ${cmd}.`);
    }

    // Porn menu (using nekos.best as fallback)
    if (cmd === 'porngif') {
      const { data } = await axios.get(nekosBest('hentai_gif'));
      if (data.results && data.results.length > 0) {
        return ctx.replyWithAnimation({ url: data.results[0].url }, { caption: 'üîû Porn GIF', ...channelButtons });
      }
      return sendBanner(ctx, `No gif found.`);
    }
    if (cmd === 'pornpic') {
      const { data } = await axios.get(nekosBest('hentai'));
      if (data.results && data.results.length > 0) {
        return ctx.replyWithPhoto({ url: data.results[0].url }, { caption: 'üîû Porn Pic', ...channelButtons });
      }
      return sendBanner(ctx, `No pic found.`);
    }
    if (cmd === 'randomporn') {
      const { data } = await axios.get(nekosBest('random_hentai'));
      if (data.results && data.results.length > 0) {
        return ctx.replyWithPhoto({ url: data.results[0].url }, { caption: 'üîû Random Porn', ...channelButtons });
      }
      return sendBanner(ctx, `No pic found.`);
    }
    if (cmd === 'pornsearch') {
      if (!args.length) return sendBanner(ctx, 'Usage: .pornsearch <tag>');
      const tag = args[0].toLowerCase();
      const { data } = await axios.get(`https://nekos.best/api/v2/${encodeURIComponent(tag)}`);
      if (data.results && data.results.length > 0) {
        return ctx.replyWithPhoto({ url: data.results[0].url }, { caption: `üîû Pornsearch: ${tag}`, ...channelButtons });
      }
      return sendBanner(ctx, `No result for tag: ${tag}`);
    }

    // Fun menu
    if (cmd === 'joke') {
      const { data } = await axios.get('https://v2.jokeapi.dev/joke/Any');
      let joke = data.type === "single" ? data.joke : `${data.setup}\n${data.delivery}`;
      return sendBanner(ctx, `üòÇ Joke:\n${joke}`);
    }
    if (cmd === 'meme') {
      const { data } = await axios.get('https://meme-api.com/gimme');
      return ctx.replyWithPhoto({ url: data.url }, { caption: `ü§£ Meme by ${data.author}`, ...channelButtons });
    }
    if (cmd === 'cat') {
      const { data } = await axios.get('https://api.thecatapi.com/v1/images/search');
      return ctx.replyWithPhoto({ url: data[0].url }, { caption: `üê± Cat`, ...channelButtons });
    }
    if (cmd === 'dog') {
      const { data } = await axios.get('https://dog.ceo/api/breeds/image/random');
      return ctx.replyWithPhoto({ url: data.message }, { caption: `üê∂ Dog`, ...channelButtons });
    }
    if (cmd === 'coinflip') {
      const result = Math.random() > 0.5 ? "Heads" : "Tails";
      return sendBanner(ctx, `ü™ô Coinflip: ${result}`);
    }
    if (cmd === 'advice') {
      const { data } = await axios.get('https://api.adviceslip.com/advice');
      return sendBanner(ctx, `üí° Advice:\n${data.slip.advice}`);
    }
    if (cmd === 'say') {
      if (!args.length) return sendBanner(ctx, 'Usage: .say <text>');
      return sendBanner(ctx, args.join(' '));
    }
    if (cmd === 'roast') {
      const { data } = await axios.get('https://evilinsult.com/generate_insult.php?lang=en&type=json');
      return sendBanner(ctx, `üî• Roast:\n${data.insult}`);
    }

    // Dev menu
    if (cmd === 'statics') {
      return sendBanner(ctx, `üìä Static Info:\nTotal Users: ${users.length}\nVersion: ${BOT_VERSION}\nOnline: CYBIX`);
    }
    if (cmd === 'listusers') {
      return sendBanner(ctx, 'üë• Users:\n' + users.map(u => `${u.name} (${u.id})`).join('\n'));
    }
    if (cmd === 'stderror') {
      return sendBanner(ctx, `STDERR: ${(typeof process.stderr !== "undefined" ? "Available" : "Not available")}`);
    }
    if (cmd === 'osinfo') {
      return sendBanner(ctx, `OS Info:\n${os.type()} ${os.release()}\nArch: ${os.arch()}\nHostname: ${os.hostname()}`);
    }
    if (cmd === 'nodever') {
      return sendBanner(ctx, `Node Version: ${process.version}`);
    }
    if (cmd === 'sysinfo') {
      return sendBanner(ctx, `System Info:\nPlatform: ${os.platform()}\nCPUs: ${os.cpus().length}\nUptime: ${(os.uptime()/60|0)}m`);
    }
    if (cmd === 'uptime') {
      return sendBanner(ctx, `Uptime: ${(process.uptime()/60|0)}m ${Math.floor(process.uptime()%60)}s`);
    }
    if (cmd === 'env') {
      return sendBanner(ctx, 'ENV:\n' + Object.entries(process.env).map(([k,v]) => `${k}=${v}`).join('\n'));
    }
    if (cmd === 'memory') {
      return sendBanner(ctx, `Memory Usage:\n${JSON.stringify(process.memoryUsage(), null, 2)}`);
    }

    // Tools menu
    if (cmd === 'qr') {
      if (!args.length) return sendBanner(ctx, 'Usage: .qr <text>');
      let url = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(args.join(' '))}`;
      return ctx.replyWithPhoto({ url }, { caption: 'üîß QR Code', ...channelButtons });
    }
    if (cmd === 'tts') {
      if (!args.length) return sendBanner(ctx, 'Usage: .tts <text>');
      let api = `https://api.streamelements.com/kappa/v2/speech?voice=Brian&text=${encodeURIComponent(args.join(' '))}`;
      return ctx.replyWithAudio({ url: api }, { title: 'üîß TTS', ...channelButtons });
    }
    if (cmd === 'translate') {
      if (args.length < 2) return sendBanner(ctx, 'Usage: .translate <lang> <text>');
      let [lang, ...txt] = args;
      let { data } = await axios.get(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(txt.join(' '))}&langpair=en|${lang}`);
      let txtOut = data.responseData.translatedText || "No translation.";
      return sendBanner(ctx, `üîß Translation:\n${txtOut}`);
    }
    if (cmd === 'shorturl') {
      if (!args.length) return sendBanner(ctx, 'Usage: .shorturl <url>');
      let { data } = await axios.get(`https://api.shrtco.de/v2/shorten?url=${encodeURIComponent(args[0])}`);
      return sendBanner(ctx, `üîß Short URL:\n${data.result.full_short_link}`);
    }
    if (cmd === 'paste') {
      if (!args.length) return sendBanner(ctx, 'Usage: .paste <text>');
      let { data } = await axios.post('https://paste.c-net.org/', args.join(' '), { headers: { 'Content-Type': 'text/plain' } });
      return sendBanner(ctx, `üîß Paste: https://paste.c-net.org/${data}`);
    }
    if (cmd === 'whois') {
      if (!args.length) return sendBanner(ctx, 'Usage: .whois <domain>');
      let { data } = await axios.get(`https://api.api-ninjas.com/v1/whois?domain=${encodeURIComponent(args[0])}`, { headers: { 'X-Api-Key': process.env.NINJAS_API_KEY || '' } });
      return sendBanner(ctx, `üîß Whois:\n${getApiText(data)}`);
    }

    // Lyrics, wallpaper, weather, text2img, yts (original)
    if (cmd === 'lyrics') {
      if (!args.length) return sendBanner(ctx, 'Usage: .lyrics <song>');
      let { data } = await axios.get(`https://some-random-api.com/lyrics?title=${encodeURIComponent(args.join(' '))}`);
      if (data && data.lyrics) return sendBanner(ctx, `üéµ Lyrics for ${data.title} by ${data.author}:\n${data.lyrics}`);
      return sendBanner(ctx, `‚ùå Lyrics not found.`);
    }
    if (cmd === 'wallpaper') {
      if (!args.length) return sendBanner(ctx, 'Usage: .wallpaper <query>');
      let { data } = await axios.get(`https://wallhaven.cc/api/v1/search?q=${encodeURIComponent(args.join(' '))}`);
      if (data && data.data && data.data[0] && data.data[0].path) {
        return ctx.replyWithPhoto({ url: data.data[0].path }, { caption: 'üñº Wallpaper', ...channelButtons });
      }
      return sendBanner(ctx, `‚ùå No wallpaper found.`);
    }
    if (cmd === 'weather') {
      if (!args.length) return sendBanner(ctx, 'Usage: .weather <location>');
      let { data } = await axios.get(`https://wttr.in/${encodeURIComponent(args.join(' '))}?format=3`);
      return sendBanner(ctx, `üå¶Ô∏è Weather:\n${data}`);
    }
    if (cmd === 'text2img') {
      if (!args.length) return sendBanner(ctx, 'Usage: .text2img <prompt>');
      let { data } = await axios.get(`https://aigc-api.vercel.app/api/stablediffusion?prompt=${encodeURIComponent(args.join(' '))}`);
      if (data.image) {
        return ctx.replyWithPhoto({ url: data.image }, { caption: 'üé® AI Image', ...channelButtons });
      }
      return sendBanner(ctx, `‚ùå Could not generate image.`);
    }
    if (cmd === 'yts') {
      if (!args.length) return sendBanner(ctx, 'Usage: .yts <query>');
      let { data } = await axios.get(`https://yts.mx/api/v2/list_movies.json?query_term=${encodeURIComponent(args.join(' '))}`);
      if (data && data.data && data.data.movies) {
        return sendBanner(ctx, data.data.movies.map(x => `${x.title}\n${x.url}`).join('\n\n'));
      }
      return sendBanner(ctx, `‚ùå No results found.`);
    }

    return false;
  } catch (e) {
    return sendBanner(ctx, `‚ùå API error for ${cmd}.\n${(e.response?.data ? JSON.stringify(e.response.data) : e.message)}`);
  }
}

bot.on('text', async (ctx, next) => {
  try {
    registerUser(ctx);
    const command = parseCommand(ctx.message.text);
    if (command) {
      await handleCommand(ctx, command);
      return;
    }
  } catch (_) {}
  await next();
});

// Keepalive HTTP Server for Render/Termux
require('http').createServer((_, res) => res.end('Bot is running')).listen(process.env.PORT || 3000);

// Start
bot.launch()
  .then(() => console.log('CYBIX BOT started.'))
  .catch(err => { console.error('Failed to start bot:', err); process.exit(1); });
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));